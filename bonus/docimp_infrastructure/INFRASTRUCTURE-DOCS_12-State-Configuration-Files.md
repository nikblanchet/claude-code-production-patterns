# Infrastructure Documentation: State & Configuration Files

## Overview

DocImp uses **configuration files** to control which files are tracked, ignored, and processed by various tools. These files form the **project boundary**, defining what's inside the project and what's external.

**Key Configuration Files:**
- **.gitignore** - Files excluded from version control
- **.prettierignore** - Files excluded from Prettier formatting
- **CLAUDE.md / CLAUDE_CONTEXT.md** - Claude Code guidance (gitignored)
- **.docimp/** - State directory (gitignored)
- **.planning/** - Planning documents (gitignored)

**Philosophy:** Explicit is better than implicit. These files document **why** certain patterns are ignored.

---

## 1. .gitignore

### Purpose

**Defines files excluded from git version control.**

**Key Principles:**
1. **Never commit generated artifacts** (build output, dependencies)
2. **Never commit secrets** (but don't rely only on .gitignore for security)
3. **Never commit personal configs** (editor settings, working documents)
4. **Never commit state** (.docimp/, .cache/)

### Full Configuration

**File: .gitignore**

```gitignore
# Python
__pycache__/
*.pyc
.venv/
.env
env/
venv/
*.egg-info/
build/

# Node
node_modules/
dist/

# OS / IDE
.DS_Store
.vscode/
.idea/
.warp/
WARP.md

# Editor temporary files
*~
*.swp
*.swo

# TypeScript build cache
*.tsbuildinfo

# Node.js caches
.npm
.eslintcache

# Environment file variants
.env.local
.env.*.local

# Build artifacts and logs
*.log
*.bak
.pytest_cache/
.mypy_cache/
.coverage

# Project-specific
CLAUDE.md
CLAUDE_CONTEXT.md

# Temporary planning and scratch files
.scratch
.planning

# Project-specific skills and agents (symlinked to external repo)
.claude/skills
.claude/agents

# State directory (working files, session reports, history)
.docimp/

# direnv
.direnv/
.envrc.local

# NOTE on credential patterns (*.key, *.pem, credentials.json, etc.):
# We intentionally do NOT include these patterns. Adding them to .gitignore
# creates false security - they don't prevent "git add -f" and give developers
# a false sense of protection. Real credential protection comes from:
# - GitHub's secret scanning (enabled by default on public repos)
# - Pre-commit hooks (e.g., detect-secrets, gitleaks)
# - Developer security training
# See: https://docs.github.com/en/code-security/secret-scanning

# Temporary implementation notes (for issue tracking)
IMPLEMENTATION_SUMMARY.md
```

### Category Breakdown

**1. Python Artifacts**

```gitignore
__pycache__/        # Compiled bytecode cache
*.pyc               # Individual bytecode files
.venv/              # Virtual environment (project-specific)
.env                # Environment variables (may contain secrets)
env/                # Alternative venv name
venv/               # Alternative venv name
*.egg-info/         # Package metadata (generated by pip install -e .)
build/              # Build artifacts (setup.py build)
```

**Why:**
- Generated by Python runtime/build tools
- Large (venv can be 100+ MB)
- Platform-specific (different on Linux vs macOS vs Windows)
- Reproducible from requirements.lock

**2. Node.js Artifacts**

```gitignore
node_modules/       # npm/yarn dependencies (can be 100+ MB)
dist/               # TypeScript build output (generated by tsc)
```

**Why:**
- Generated by npm install / tsc
- Extremely large (node_modules often 200+ MB)
- Reproducible from package-lock.json

**3. OS / IDE Files**

```gitignore
.DS_Store           # macOS Finder metadata
.vscode/            # VS Code workspace settings
.idea/              # IntelliJ IDEA project files
.warp/              # Warp terminal settings
WARP.md             # Warp-specific markdown
```

**Why:**
- Personal configuration (different per developer)
- IDE-specific (not relevant to other editors)
- Can be regenerated

**Exception:** Some projects commit `.vscode/` with shared settings. DocImp chooses not to (allows developer choice).

**4. Editor Temporary Files**

```gitignore
*~                  # Vim backup files (filename~)
*.swp               # Vim swap files (open file state)
*.swo               # Vim swap file variant
```

**Why:**
- Temporary files created during editing
- Not part of actual codebase
- Automatically cleaned up by editors

**5. Build Caches**

```gitignore
*.tsbuildinfo       # TypeScript incremental build cache
.npm                # npm cache
.eslintcache        # ESLint result cache
.pytest_cache/      # pytest cache
.mypy_cache/        # mypy type checking cache
```

**Why:**
- Performance optimization (faster rebuilds)
- Not needed for clean builds
- Can be regenerated

**6. Environment Variables**

```gitignore
.env                # Base environment file
.env.local          # Local overrides
.env.*.local        # Environment-specific local overrides
```

**Why:**
- May contain secrets (API keys, database URLs)
- Developer-specific (different per machine)
- Should use .env.example for documentation instead

**7. Logs and Backups**

```gitignore
*.log               # Application logs
*.bak               # Backup files (created by DocImp's DocstringWriter)
.coverage           # Python coverage data file
```

**Why:**
- Transient data (changes frequently)
- Can be large
- Not part of source code

**8. Project-Specific: Claude Code**

```gitignore
CLAUDE.md           # Claude Code technical guidance
CLAUDE_CONTEXT.md   # Personal project context
```

**Why:**
- CLAUDE.md: Gitignored to keep under 40K limit (uses external docs pattern)
- CLAUDE_CONTEXT.md: Personal preferences, job application context

**Rationale:** These files are for Claude Code sessions, not for public documentation.

**9. Project-Specific: Planning**

```gitignore
.scratch            # Temporary notes
.planning           # PLAN.md and working documents
```

**Why:**
- Personal working documents (PLAN.md progress tracking)
- Not relevant to other contributors
- Would create merge conflicts if committed

**10. Project-Specific: Symlinks**

```gitignore
.claude/skills      # Symlink to external custom-claude-skills repo
.claude/agents      # Symlink to external agents
```

**Why:**
- Symlinks to external repositories
- Different per developer (different repo locations)
- Actual content versioned in external repos

**11. Project-Specific: State**

```gitignore
.docimp/            # Session reports, workflow state, transaction history
```

**Why:**
- Working files (session-reports/, workflow-state.json)
- Personal progress (audit sessions, improve sessions)
- Would create conflicts if multiple developers commit state

**12. direnv**

```gitignore
.direnv/            # direnv-generated binaries
.envrc.local        # Personal direnv overrides
```

**Why:**
- `.direnv/`: Generated wrapper scripts (python, pip, pytest interceptors)
- `.envrc.local`: Personal settings (developer-specific paths)

### Security Note: Credentials

**DocImp intentionally does NOT include credential patterns:**

```gitignore
# NOT included:
# *.key
# *.pem
# credentials.json
# secrets.yaml
```

**Rationale:**

1. **False sense of security**: `.gitignore` doesn't prevent `git add -f`
2. **GitHub secret scanning**: Enabled by default on public repos
3. **Pre-commit hooks**: Tools like `detect-secrets` or `gitleaks` provide real protection
4. **Developer training**: Best practice is to never create credential files in repo

**Real credential protection comes from:**
- GitHub's secret scanning (automatic on public repos)
- Pre-commit hooks (gitleaks, detect-secrets)
- Developer security training
- Using environment variables (`.env` which IS gitignored)

**Reference:** https://docs.github.com/en/code-security/secret-scanning

---

## 2. .prettierignore

### Purpose

**Defines files excluded from Prettier formatting.**

**Why Separate from .gitignore?**

Some gitignored files should still be formatted if they exist:
- Example: Developer might have local `test.js` for debugging
- Prettier should format it, but git shouldn't track it

Some committed files shouldn't be formatted:
- Example: `.github/workflows/*.yml` (preserve exact YAML formatting)

### Full Configuration

**File: .prettierignore**

```
# Dependencies
node_modules/

# Build output
dist/
build/
*.tsbuildinfo

# Coverage
coverage/

# Cache
.cache/
.eslintcache

# Test fixtures with intentional formatting issues
test-samples/malformed/
test-samples/mixed-valid-invalid/

# Git metadata
.git/

# GitHub workflows (preserve exact YAML formatting)
.github/workflows/

# Config files that need specific formatting
tsconfig*.json
```

### Category Breakdown

**1. Dependencies**

```
node_modules/
```

**Why:**
- Third-party code
- No need to format (not our code)
- Faster Prettier execution (skips 1000s of files)

**2. Build Output**

```
dist/
build/
*.tsbuildinfo
```

**Why:**
- Generated code
- Will be overwritten on next build
- Formatting wastes time

**3. Coverage Reports**

```
coverage/
```

**Why:**
- Generated HTML reports
- Not source code
- Reformatted on next test run

**4. Test Fixtures**

```
test-samples/malformed/
test-samples/mixed-valid-invalid/
```

**Why:**
- Intentionally malformed code for testing parsers
- Formatting would break tests
- Need to preserve exact syntax errors

**Example:** `test-samples/malformed/python_missing_paren.py`

```python
def broken(
    # Missing closing parenthesis - intentional!
```

If Prettier formatted this, it would either:
- Fix the syntax error (breaking the test)
- Fail to format (causing CI to fail)

**5. Git Metadata**

```
.git/
```

**Why:**
- Binary files and git internals
- Not meant to be formatted
- Prettier should never touch

**6. GitHub Workflows**

```
.github/workflows/
```

**Why:**
- YAML formatting is precise (indentation matters)
- GitHub Actions may be sensitive to formatting changes
- Preserve exact formatting from GitHub's examples

**Trade-off:** Manual formatting required, but prevents subtle CI breakage.

**7. Config Files**

```
tsconfig*.json
```

**Why:**
- TypeScript compiler is picky about JSON format
- Prettier's 100-char printWidth for JSON may wrap in unexpected ways
- Preserve exact formatting from TypeScript documentation

**Alternative:** Remove from `.prettierignore` and manually verify after formatting.

---

## 3. CLAUDE.md / CLAUDE_CONTEXT.md

### CLAUDE.md

**Purpose:** Technical guidance for Claude Code sessions.

**Gitignored:** Yes

**Rationale:**
- Keeps file under 40K character limit
- Uses external docs pattern (@docs/patterns/*.md imports)
- Personal working document (not public documentation)

**Contents:**
- Commands and quick reference
- Architecture overview
- Critical constraints (uv run prefix, Node 24+)
- Common patterns (add parser, plugin, command)
- Import references to docs/patterns/

**Maintenance:**
- Check size: `wc -c CLAUDE.md`
- Keep under 40K (current: 27,792 bytes)
- Move detailed content to docs/patterns/

### CLAUDE_CONTEXT.md

**Purpose:** Personal project context for Claude Code.

**Gitignored:** Yes

**Rationale:**
- Contains personal information (job application context)
- Developer preferences (communication style)
- Not relevant to public project

**Contents:**
- Project background (portfolio project for Anthropic job)
- Job requirements being demonstrated
- Developer profile and experience
- Writing preferences (professional tone)
- Error handling procedures

---

## 4. .docimp/ State Directory

### Purpose

**Stores all working state and session data** (analogous to `.git/`).

**Gitignored:** Yes - entire directory

**Rationale:**
- Personal progress (audit sessions, improve sessions)
- Transient data (workflow state, transaction history)
- Would create merge conflicts if committed

### Directory Structure

```
.docimp/
├── session-reports/           # Analysis, audit, plan, improve results
│   ├── analyze-latest.json
│   ├── audit.json
│   ├── plan.json
│   ├── audit-session-{uuid}.json
│   └── improve-session-{uuid}.json
├── workflow-state.json        # Command execution tracking
├── history/                   # Workflow state snapshots
│   └── workflow-state-2025-11-12T14-30-00-123Z.json
└── state/                     # Transaction system
    └── .git/                  # Side-car git repository
```

### Key Files

**session-reports/analyze-latest.json**

```json
{
  "total_items": 23,
  "documented_items": 15,
  "coverage_percent": 65.2,
  "items": [...],
  "by_language": {...}
}
```

**Purpose:** Latest analysis results (used by status command)

**workflow-state.json**

```json
{
  "schema_version": "1.0",
  "last_analyze": {
    "timestamp": "2025-11-12T14:30:00Z",
    "item_count": 23,
    "file_checksums": {...}
  },
  "last_audit": null,
  "last_plan": null,
  "last_improve": null
}
```

**Purpose:** Tracks command execution for dependency validation and staleness detection

**state/.git/**

Side-car git repository for transaction tracking (never touches user's `.git/`).

---

## 5. .planning/ Directory

### Purpose

**Stores planning and scratch documents** for development workflow.

**Gitignored:** Yes - entire directory

**Rationale:**
- Personal working documents (PLAN.md progress tracking)
- Would create merge conflicts if committed
- Different developers have different planning styles

### Directory Structure

```
.planning/
├── PLAN.md                          # Main execution plan (gitignored)
├── development-workflow.md          # Methodology (committed in .docimp-shared)
├── workflow-state-master-plan.md    # Feature-specific plan
├── ARCHITECTURE_DIAGRAMS.md         # Visual diagrams
└── IMPLEMENTATION_SUMMARY.md        # Temporary notes
```

**Note:** Some planning files are committed in `.docimp-shared/.planning/` for sharing across worktrees.

---

## 6. Configuration Management

### Verification Commands

**Check what's gitignored:**

```bash
# List all gitignored files
git ls-files --others --ignored --exclude-standard

# Check if specific file is ignored
git check-ignore -v .docimp/workflow-state.json
# Output: .gitignore:58:.docimp/    .docimp/workflow-state.json
```

**Check what's not ignored (tracked files):**

```bash
# List all tracked files
git ls-files

# Check if specific file is tracked
git ls-files CLAUDE.md
# Empty output = not tracked (gitignored)
```

### Adding New Patterns

**1. Identify pattern to ignore:**

```bash
# Find all .log files
find . -name "*.log"

# Check if already ignored
git check-ignore -v debug.log
```

**2. Add to .gitignore:**

```bash
echo "*.log" >> .gitignore
```

**3. If files already committed, remove from tracking:**

```bash
git rm --cached *.log
git commit -m "Remove log files from tracking"
```

**4. Verify:**

```bash
git check-ignore -v debug.log
# Output: .gitignore:40:*.log    debug.log
```

### Global vs Local .gitignore

**Local .gitignore (project root):**
- Project-specific patterns
- Committed to repository
- Applies to all contributors

**Global .gitignore (~/.gitignore_global):**
- Personal patterns (OS files, editor configs)
- Not committed
- Applies to all your git repos

**Example global .gitignore:**

```bash
# Configure global gitignore
git config --global core.excludesfile ~/.gitignore_global

# Add personal patterns
cat > ~/.gitignore_global <<EOF
.DS_Store
.vscode/
.idea/
*~
*.swp
EOF
```

**Benefits:**
- Project .gitignore stays clean
- Personal preferences don't clutter project
- Works across all repositories

---

## Quick Reference

### Configuration File Purposes

| File | Gitignored? | Purpose |
|------|-------------|---------|
| .gitignore | No | Exclude files from version control |
| .prettierignore | No | Exclude files from Prettier formatting |
| CLAUDE.md | Yes | Claude Code technical guidance |
| CLAUDE_CONTEXT.md | Yes | Personal project context |
| .docimp/ | Yes | Session reports, workflow state, transactions |
| .planning/ | Yes | PLAN.md and working documents |
| .direnv/ | Yes | direnv-generated wrapper scripts |

### Common Patterns

**Never commit:**
- Dependencies (node_modules/, .venv/)
- Build artifacts (dist/, build/, *.pyc)
- Personal configs (.vscode/, .idea/)
- Secrets (.env, *.key, credentials.json)
- State (.docimp/, .cache/)

**Always commit:**
- Source code (src/, cli/, analyzer/)
- Configuration (tsconfig.json, pyproject.toml)
- Documentation (README.md, docs/)
- Tests (tests/, __tests__/)

**Depends on project:**
- Editor settings (.vscode/) - DocImp gitignores
- Lock files (package-lock.json) - DocImp commits
- Coverage reports (coverage/) - DocImp gitignores

### Verification Commands

```bash
# Check if file is gitignored
git check-ignore -v filename

# List all gitignored files in directory
git ls-files --others --ignored --exclude-standard

# List all tracked files
git ls-files

# Remove file from tracking (but keep on disk)
git rm --cached filename
```

---

## Troubleshooting

### Problem: File Still Tracked After Adding to .gitignore

**Symptoms:**
- Added `CLAUDE.md` to .gitignore
- `git status` still shows it as modified
- `git check-ignore CLAUDE.md` confirms it's ignored

**Cause:** File was committed before being added to .gitignore.

**Solution:**

```bash
# Remove from git tracking (keeps file on disk)
git rm --cached CLAUDE.md

# Commit the removal
git commit -m "Remove CLAUDE.md from tracking"

# Verify
git status
# CLAUDE.md should not appear
```

### Problem: Accidentally Committed .env File with Secrets

**Symptoms:**
- Committed `.env` file containing API keys
- GitHub shows secret scanning alert

**Solution:**

**DO NOT just delete the file in a new commit - secrets remain in git history!**

```bash
# Option 1: Remove from all history (requires force push)
git filter-branch --force --index-filter \
  "git rm --cached --ignore-unmatch .env" \
  --prune-empty --tag-name-filter cat -- --all

# Force push (WARNING: destructive)
git push --force --all

# Option 2: Use BFG Repo-Cleaner (faster, safer)
bfg --delete-files .env
git reflog expire --expire=now --all && git gc --prune=now --aggressive
git push --force

# Option 3: If public repo, rotate all secrets immediately
# (Most important step regardless of which option used)
```

**Prevention:**
- Never create credential files in repo
- Use environment variables
- Configure pre-commit hooks (gitleaks, detect-secrets)

### Problem: direnv Files Committed

**Symptoms:**
- `.direnv/bin/python` shows in `git status`
- Should be gitignored but isn't

**Solution:**

```bash
# Verify .gitignore pattern
grep direnv .gitignore
# Should show: .direnv/

# If missing, add it
echo ".direnv/" >> .gitignore

# Remove from tracking
git rm -r --cached .direnv/
git commit -m "Remove direnv generated files"
```

### Problem: Can't Commit File Matching Gitignore Pattern

**Symptoms:**
- Need to commit `test-samples/special-case.pyc` for testing
- `.gitignore` has `*.pyc` pattern
- `git add` ignores the file

**Solution:**

```bash
# Force add the file (overrides .gitignore)
git add -f test-samples/special-case.pyc

# Or add exception to .gitignore
echo "!test-samples/special-case.pyc" >> .gitignore
git add test-samples/special-case.pyc
```

**Gitignore exception syntax:**

```gitignore
# Ignore all .pyc files
*.pyc

# Except this one
!test-samples/special-case.pyc
```

---

## Summary

DocImp uses **configuration files** to define the project boundary:

- **.gitignore** - Excludes generated artifacts, dependencies, personal configs, state
- **.prettierignore** - Excludes test fixtures, build output, sensitive YAML
- **CLAUDE.md / CLAUDE_CONTEXT.md** - Claude Code guidance (gitignored, under 40K limit)
- **.docimp/** - State directory (gitignored, session reports and workflow state)
- **.planning/** - Planning documents (gitignored, personal working docs)

**Key Principles:**

- **Never commit generated artifacts** (reproducible from source)
- **Never commit secrets** (use environment variables + secret scanning)
- **Never commit personal configs** (different per developer)
- **Explicit is better than implicit** (comment why patterns are ignored)

**Security:**

- Don't rely on .gitignore for credential protection
- Use GitHub secret scanning + pre-commit hooks
- Rotate secrets immediately if accidentally committed

**Next Steps**: See `INFRASTRUCTURE-DOCS_13-Dependency-Lock-Files.md` for package-lock.json, uv.lock, and requirements.lock management.
